Container Layer: 

As we know a docker image is made of a series of layers and each layer is only a set of differences from the layer before it.
The layers are stacked on top of each other.
When we create a new container, a new writable layer is added to the top of this stack. This new layer is called container layer.
All the layers below this container layer are readonly layers and writes can only be made to the topmost container layer.

consider below, figure:
https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/#images-and-layers

A software which is responsible for making these layers interact is called storage driver. Different storage drivers are available such as:
aufs, OverlayFS, btrFS etc.

When a container is deleted its writable container layer is also deleted. However, other layers which are part of an image remain unchanged.


Every container has its own writable container layer, and the changes they make to filesystem are stored in their very own container layer. 
This is the reason multiple containers can run same image without conflicting with other container instances.
(NOTE: This is called COPY on write technique explained in union file system topic)

consider 2nd figure from:
https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/#container-and-layers

The writable layer for each container is stored in following location: 
sudo ls /var/lib/docker/containers

By default, all the layers are stored in: /var/lib/docker/aufs<storage-driver>

docker history <imageid>, shows the layers out of which supplied image is made of.

-------------------------------------------------------------------------------------------------------------------------------

As we have seen there are some downsides of storing data in Container Layer, such as:
a:) The data wont persist when the container is deleted.
b:) The container writable layer is tightly coupled with Host m/c, Thus its not easy to migrate container data.
c:) Writing into a container’s writable layer requires a storage driver. The storage driver provides a union filesystem, using the Linux kernel. 
    This extra abstraction reduces performance.

The solution is to mount host data onto container. There are three different ways of mounting as provided by docker:
1. Data Volumes.  => are stored in a part of the host filesystem which is managed by Docker (/var/lib/docker/volumes/).
2. Bind Mounts.   => may be stored anywhere on the host system.
3. TmpFS volumes. => are stored in the host system’s memory only, and are never written to the host system’s filesystem.

These can be visualized as:
consider first figure:
https://docs.docker.com/engine/admin/volumes/#choose-the-right-type-of-mount


Data Volumes: 

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 
While bind mounts are dependent on the directory structure of the host machine, volumes are completely managed by Docker (always stored /var/lib/docker/volumes/).

Also, Volumes are often a better choice than persisting data in a container’s writable layer, because using a volume does not increase the size of containers using it, and the volume’s contents exist outside the lifecycle of a given container.

Create a volume:
docker volume create my-vol # name of volume.

List volumes:
docker volume ls

Inspect a volume:
docker volume inspect my-vol

Remove a volume:
docker volume rm my-vol

Start a container with a volume:
docker run -d \
  -it \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest

If you start a container with a volume that does not yet exist, Docker creates the volume for you. The above example mounts the volume myvol2 into /app/ in the container.

NOTE: If you start a container which creates a new volume, as above, and the container has files or directories in the directory to be mounted (such as /app/ above), the directory’s contents will be copied into the volume. The container will then mount and use the volume, and other containers which use the volume will also have access to the pre-populated content.

start a container with a readonly volume:
docker run -d \
  -it \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly \
  nginx:latest


Bind Mounts:

When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory does not need to exist on the Docker host already. It is created on demand if it does not yet exist.

Start a container with a bind mount:
docker run -d \
  -it \
  --name devtest \
  --mount source=$(pwd)/target,target=/app \
  nginx:latest


NOTE: If you bind-mount into a non-empty directory on the container, the directory’s existing contents will be overshadowed by the bind mount.
 It is surprising and this behavior differs from that of docker volumes.

Read only bind mount:
docker run -d \
  -it \
  --name devtest \
  --mount source=$(pwd)/target,target=/app,readonly \
  nginx:latest


TmpFS mounts:
There may be cases where you do not want to store a container’s data on the host machine, but you also don’t want to write the data into the container’s writable layer.

A tmpFS mount is removed as soon as the container stops.

Limitations of tmpfs containers:
 -> tmpfs mounts cannot be shared among containers.
 -> tmpfs mounts only work on Linux containers, and not on Windows containers.

Start a container with tmpfs mount:
docker run -d \
  -it \
  --name tmptest \
  --mount type=tmpfs,destination=/app \
  nginx:latest


########################################################################################################
Data Volumes:
https://docs.docker.com/engine/tutorials/dockervolumes/#volume-labels

Understanding union filesystem?
http://www.thegeekstuff.com/2013/05/linux-aufs
http://www.linuxjournal.com/article/7714







Exercise:
Mount a existing directory to container and see if its content changes on realtime inside container(done).
