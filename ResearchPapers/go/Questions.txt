io.Reader
------------

Reader is an interface used to read data bytes. Following is the signature.

type Reader interface {
        Read(p []byte) (n int, err error)
}

It reads the number of bytes equal to the length of `p`.  `n` tells the number of bytes actually read.

Although, in most of the cases len(p) equals n, there may be some scenarios where len(p) is greater than n.
Such scenarios are:
1. End Of File is reached.
2. An error is encountered after reading atleast one byte.
Also, its not required to check for error in such cases bcoz, A return value of n > 0 and at the same time err != nil is truly possible.
However, the next subsequent call will return n==0 and err != nil. So a check for error should be like:

if err != nil and n == 0 {
    // its a error.
    //next Read should return 0, error. 
} 

and not like:

if err != nil {

} 

Also, a return of n==0 and err == nil is not possible. If such a case arises, itshould be err == EOF.

io.Closer
--------------

A closer interface has following signature.

type Closer interface {
        Close() error
}

io.ReadCloser
-------------------

ReadCloser is the interface that groups the basic Read and Close methods. 

type ReadCloser interface {
        Reader
        Closer
}

ioutil.NopCloser()
---------------------
 Its a utility method, its takes in io.Reader or io.ReadCloser and attaches a dummy close method to it.
 Note: It is helpful when the `Close()` method does not need to be called.

 todo:
 1. y nil check does not work for interfaces.
 2. context
 3. sync.Waitgroup.




