##  Arrays :-
---
Arrays are fixed length and homogeneous. i.e once declared there length cannot be changed and every element of an array will contain 
same type of data.

#### Declaration:
```
var arr1 [5]int //Memory for the array is allocated at the time of declaration itself.
```

The above statement declares an array of length 5, which contains integer type value.
In Go, length of the array is part of its type, this means the type of above array is [5]int and not []int.
Therefore, an array [5]int is of different type than an array [10]int. (This is wierd but true).

Arrays are **Value type**. So, when arrays are passed between functions a copy of the array is created and passed.

The address of an array can taken as:
```
var arr2 *[5]int = &arr1  //this is also called pointer to an array.
```

**new()** function can also be used to get pointer to an array during declaration:
var arr2 *[5]int = new([5]int)

           arr2                   [5]int 
          [0x2345sde4] -------> [0][0][0][0][0]  

Consider following program for better understanding of above concepts:
```
  func main() {
    var arr1 [5]int
	var arr2 *[5]int
    var arr3 = new([5]int)
	var arr4 = &arr1

	arr2 = arr3
	
	fmt.Printf("\n val:%v, type:%T", arr1, arr1)
	fmt.Printf("\n val:%v, type:%T", arr2, arr2)
	fmt.Printf("\n val:%v, type:%T", arr3, arr3)
	fmt.Printf("\n val:%v, type:%T", arr4, arr4)

	arr1 = [5]int{1, 2, 3, 4, 5}
	arr2[2] = 7

	fmt.Printf("\n\n val:%v, type:%T", arr1, arr1)
	fmt.Printf("\n val:%v, type:%T", arr2, arr2)
	fmt.Printf("\n val:%v, type:%T", arr3, arr3)
	fmt.Printf("\n val:%v, type:%T", arr4, arr4)
  }
OUTPUT:
 val: [0 0 0 0 0], type: [5]int
 val:&[0 0 0 0 0], type:*[5]int
 val:&[0 0 0 0 0], type:*[5]int
 val:&[0 0 0 0 0], type:*[5]int

 val: [1 2 3 4 5], type: [5]int
 val:&[0 0 7 0 0], type:*[5]int
 val:&[0 0 7 0 0], type:*[5]int
 val:&[1 2 3 4 5], type:*[5]int
```

#### Other Declaration formats:
```
var arr1 = [5]string{2:"hola", 4:"pola"}
var arr2 = [...]int{1,2,3,4,5} //lazy declaration syntax, in this the compiler picks the length of array from the 
number of items given in declaration, in this case 5 so array is of s[5]int type.
```

#### Multidimensional arrays:
Go's multidimensional arrays are always rectangular (can also be square).

var arr1 [3][5]int
var arr2 [2][2][2]strings


## Slice:-
---
A slice is a reference to a particular section of an array. This subsection can be as small as a single array element and as big as whole array.
Slice is a **reference type**.

Unlike arrays, slices can grow and shrink in size during program execution. Minimum size of a slice is 0 and maximum is len(arr) to which
slice references.

#### Slice declaration:
```    
var slice1 []type = arr1[startIndex:endIndex]
```    
// items are included from specified startIndex to specified endindex. Item at startIndex is **included**, Item at endIndex is **excluded**. 


                                  |----------------slice2[7:19]-------------|
                                  |                                         |
             |-----slice1[0:9]----|---|                                     |
             |                    |   |                                     | 
             |                    |   |                                     |
            [0][1][2][3][4][5][6][7][8][9][10][11][12][13][14][15][16][17][18][19][20][21][22]  // arr1
             |                                                                               | 
             |                                                                               |
             |-------------------------slice3[0:len(arr)]------------------------------------| 


The above illustrates array arr1 broken up into three slices slice1[0:9], slice2[7:19] and slice3[0:23].

**len(slice)** => gives the current length of the slice.
 This can be calculated simply as endIndex - startIndex
So, 
    len(slice1) = 9  - 0  = 9
    len(slice2) = 17 - 9 = 12
    len(slice3) = 23 - 0 = 23 

**cap(slice)** => gives the maximum length that the slice can attain.
 This can be calculated as len(slice) + len(array beyond slice)
  = len(slice) + (len(arr1) - endIndex)
So,
    cap(slice1) = 9 + (23 - 9)   = 23
    cap(slice2) = 12 + (23 - 19) = 16
    cap(slice3) = 23 + (23 - 23) = 23

> A Slice can only only grow in forward direction not backwards and cannot grow beyond length of array to which they reference.

For any slice, following is always true: 0 <= len(slice) <= cap(slice)

#### Some unusual slice declarations:

var slice1 = arr1[:3] //if the startindex is not specified it means its 0. = arr1[0:3]
var slice1 = arr1[3:] //if the end index is not specified it means its len(arr). = arr1[3:len(arr)]
var slice1 = arr1[:]  //if both are not specified means it takes up whole array.

A slice can be simply declared as:
var slice = []int{1, 2, 3, 4, 5} //NOTE, that its a slice declaration and not array declaration as size is not mentioned.
  In this case, a array of [5]int is created and a slice [0:len(arr)] is made out of it.



                                     [0][1][2][3][4]   => [5]int
                                                   
                                     |             |
                                     |-- slice[:] -|   =>  []int , len = 5, cap = 5 

#### Slice Tricks:

Remove last item of the slice:
slice1 = slice1[0 : len(slice1)-1]

Expand/Grow slice to its max capacity:
slice1 = slice1[ : cap(slice1)]

Break a slice into two equal parts:
slice1 = slice1[ : (len(slice1)/2)] + slice1[(len(slice1)/2) : ]

Slice of length 0:
slice1 = slice1[3:3] // if the startIndex == endIndex it will create a slice of 0 length.


#### Memory Representation of slice:

A slice is a structure with 3 fields:
a:) Pointer to underline array. (This pointer points to startIndex specified in slice creation)
b:) length of slice
c:) maximum length the slice can attain.
    __________________________
   |                          |
   | ptr   | len  |  cap      | // I am a SLice
   |__________________________|

Due, to the above structure Slice have no way to grow backwards it can only grow forwards.

#### Memory Consumption of a slice.

As per Go Coding terms, a slice is represented by following structure:
```
type SliceHeader struct {
        Data uintptr   // pointer to actual underlying array
        Len  int       // length of slice
        Cap  int       // Capacity of slice
}
```
Since, we know that integers take 4 bytes on 32-bit systems and 8 bytes on 64-bit systems. The `Len` and `Cap` will take 8 bytes each.
Similarly, a pointer also takes 8 bytes on a 64-bit system, Thus, `Data` field will also take 8 bytes.
Total Size of struct will be given as : 8 + 8 + 8 = 24 bytes.
Thus a slice takes up **24 bytes** (Ignoring the size of underlying Array). 

And since we know that each block of memory can have 1 byte of data. It will take 24 Memory blocks to store it.



Also, incase the slice is trimmed from start there is no way to undone it. Consider following example:
```
	var slice1 = []int{1, 2, 3, 4, 5}
	fmt.Printf("\n len:%v, cap:%v, val:%v", len(slice1), cap(slice1), slice1)

	slice1 = slice1[2:]
	fmt.Printf("\n len:%v, cap:%v, val:%v", len(slice1), cap(slice1), slice1)

OUTPUT:
       len:5, cap:5, val:[1 2 3 4 5]
       len:3, cap:3, val:[3 4 5]
```

Inthe above example first few items of the slice is trimmed and the capacity of the slice also drops and now there is no way to bring those items
back.
> IMPORTANT!! We cannot provide -ve values for StartIndex and Endindex that is illegal!!

> Avoi using a pointer to a slice because slice is already a reference type.

#### use of make()

make function can be used to create slice:

var slice1 = make([]int, 5, 10)

make takes 3 arguments,
1. type of slice
2. length of slice
3. capacity of slice.

In case the length and capacity needs to be same, third parameter can be removed.
var slice1 = make([]int, 10)

#### Multidimensional Slices:

Slices can contain other slices too. This nesting can go to any level.

Following example shows, how to work with multidimensional slices:

```
func main() {

	var arr1 = [5]int{1, 2, 3, 4, 5}

	var slice1 = arr1[1:2] //2
	var slice2 = arr1[2:5] //3,4,5

	var slice3 = [][]int{slice1, slice2}
	var slice4 = [][]int{[]int{1, 2}, []int{1, 2, 3}}

	fmt.Printf("\n len:%v, cap:%v, val:%v, typ:%T", len(slice3), cap(slice3), slice3, slice3)
	fmt.Printf("\n len:%v, cap:%v, val:%v, typ:%T", len(slice4), cap(slice4), slice4, slice4)

}

OUTPUT:
 len:2, cap:2, val:[[2] [3 4 5]], typ  :[][]int
 len:2, cap:2, val:[[1 2] [1 2 3]], typ:[][]int 
```

#### Reclising, Appending, Copying:

Reclising is the procedure of growing the size of a slice.

grow slice by 1.
slice1 = slice1[:len(slice1)+1]

A slice can be grown only till it does not reaches the length of the underlying array. After that growing a slice is impossible.
So, How to increase the size of slice once it reaches its max capacity?
In such a case,
a:) A new slice is created with the larger size capacity.
b:) contents of the original slice is copied to this new slice.
c:) old slice is overriden with new slice.

Following program illustrates the same:
```
func main() {

	//slice1 has len=3, cap=3, we need to add 4,5,6 to this slice but it cannot grow further.
	var slice1 = []int{1, 2, 3}
	fmt.Printf("\n len:%v, cap:%v, val:%v, typ:%T", len(slice1), cap(slice1), slice1, slice1)
	//create a new slice with larger space
	var slice2 = make([]int, 7)
	//copy contents of slice1 to slice2
	copy(slice2, slice1)
	slice1 = slice2
	slice1[3] = 4
	slice1[4] = 5
	slice1[5] = 6

	fmt.Printf("\n len:%v, cap:%v, val:%v, typ:%T", len(slice1), cap(slice1), slice1, slice1)

}

OUTPUT:

 len:3, cap:3, val:[1 2 3], typ:[]int
 len:7, cap:7, val:[1 2 3 4 5 6 0], typ:[]int
```

The above procedure can be simply done via using **append()** which provides above functionality inbuilt.

func append(s []T, x ...T)

It accepts two parameters:
1. slice which needs to be grown.
2. items that needs to be appended.
  Firstly, it tries to grow slice upto its max capacity once that is reached it uses the procedure descibed in previous section
to create a new bigger slice and append values to it.

```
func main() {

	//slice1 has len=3, cap=3, we need to add 4,5,6 to this slice but it cannot grow further.
	var slice1 = []int{1, 2, 3}
	fmt.Printf("\n len:%v, cap:%v, val:%v, typ:%T", len(slice1), cap(slice1), slice1, slice1)
	//use append
	slice1 = append(slice1, 4, 5, 6)

	fmt.Printf("\n len:%v, cap:%v, val:%v, typ:%T", len(slice1), cap(slice1), slice1, slice1)
}
OUTPUT:
len:3, cap:3, val:[1 2 3], typ:[]int
len:6, cap:6, val:[1 2 3 4 5 6], typ:[]int
```

> Trick: If u want to append a slice y to slice x, simple do append(x, y...)

#### Garbage collection of slices:

A slice points to an underlying array, this array can be very large in size. 
No matter how small the slice is, the whole array needs to be kept in memory till there is even one process using the tiny slice.

#### Some Append Tricks:

1. Append slice b to a
    a = append(a, b...)

2. copy slice a to slice b.
    copy(b, a)

3. Delete item at index i.
    a = append(a[:i], a[i+1,:]...)

4. cut from index i till j
    a = append(a[:i], a[j+1:]...)

5. extend slice a with new slice of length j
    a = append(a, make([]T, j)...)

6. insert slice of length j at index i.
    b := make([]T, j)
    a = append(a[:i], append(b, a[i:]...)...)

 
#### Choosing b/w []int and *[]int.
Though Slices are referred to as Reference Type. They posses some interesting properties of value types. Stated below:
1. Assignment creates a copy.

```
slice1 := []string{"A", "B", "C"}
slice2 := slice1 //Assigning is not by reference, So slice2 is actually a copy of slice1 and nothing more. 
```
Below is the sample code to illustrate the same:
```
func main() {

	slice1 := []string{"A", "B", "C"}
	slice2 := slice1

	slice1 = slice1[:len(slice1)-1] //Remove last element of slice1

	fmt.Printf("%v\n", slice1)
	fmt.Printf("%v\n", slice2)
}
//OutPut:
[A B]
[A B C]
```
2. When passing through function also creates a copy. Below is the code example:
```
func main() {

	slice1 := []string{"A", "B", "C"}

	testslice(slice1)
	fmt.Printf("%v\n", slice1)
}

func testslice(sliceCopy []string) { //Remove last element
	sliceCopy = sliceCopy[:len(sliceCopy)-1]
}
//Output:
[A B C]
```

So, Now we know that a pointer to slice is slightly cheaper than passing the slice directly to the function. As passing directly, will create
a new copy of slice which will take up 24 bytes of additional memory, While, passing a pointer will take only 8 bytes of additional memory. 

Since the difference b/w the memory usage of the two is **not** enormously higher, It would make sense to pass a slice directly and only to use the
pointer approach when you need to modify the slice itself. Thus, avoiding the additional complexities imposed by pointer. 


#### Choosing b/w []struct and []*struct
Refer Structs section for this.

#### Memory consumption of a string

A string is nothing but a slice of bytes. In Go code a string is defined as:
```
type stringStruct struct {
    len int               //length of string
    str unsafe.Pointer    //pointer to actual string data
}
```
Thus a string takes up only 16 bytes (8 + 8) on stack and rest of the string data is kept on heap.

